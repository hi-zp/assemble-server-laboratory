## database

### 分页模式

#### Offset Pagination（偏移分页）：

* **含义**：使用偏移量和限制数量来确定结果集中的页码和记录数量。
* **特点**：简单直观，客户端指定页码和每页记录数量，服务器根据参数执行查询并返回结果。
* **区别**：
使用偏移量和限制数量来确定页码和记录数量。
随着数据集增长，偏移分页可能效率较低，因为服务器需要跳过大量记录。
当数据集变化时，页码与实际数据对应关系可能发生变化，导致分页结果不一致。
使用场景：适用于较小的数据集，简单的分页需求，并且数据集不会频繁变化的情况。

#### Cursor Pagination（游标分页）：

* **含义**：使用游标作为标记来表示结果集中的位置，实现高效和一致的分页体验。
* **特点**：可预测性和可扩展性，不受数据变化影响，适用于大型数据集。
* **区别**：
使用游标标记结果集中位置。
分页结果的一致性不受数据变化影响。
可处理大型数据集，不需要加载整个数据集到内存中。
使用场景：适用于大型数据集，复杂的分页需求，以及需要保持分页结果一致性的情况。

## mikroorm

### 管理实体对象与数据库交互的核心方法

#### `persist(entity: Entity): Promise<void>`

* **含义**：将实体对象添加到数据库中，但不会立即保存到数据库。
* **区别**：`persist` 方法只是将实体对象添加到数据库中，但不会立即执行数据库操作。需要调用 `flush` 方法才能将更改保存到数据库。
* **使用场景**：适用于需要在稍后的时间点批量保存多个实体对象的情况，以提高性能。

#### `persistAndFlush(entity: Entity): Promise<void>`

* **含义**：将实体对象添加到数据库并立即保存到数据库。
* **区别**：`persistAndFlush` 方法将实体对象添加到数据库并立即执行数据库操作，将更改保存到数据库。
* **使用场景**：适用于需要立即将实体对象保存到数据库的情况，例如在创建新记录后立即需要访问该记录的标识符。

#### `remove(entity: Entity): Promise<void>`

* **含义**：从数据库中删除实体对象，但不会立即执行数据库操作。
* **区别**：`remove` 方法只是将实体对象标记为待删除状态，但不会立即执行数据库操作。需要调用 `flush` 方法才能将更改保存到数据库。
* **使用场景**：适用于需要在稍后的时间点批量删除多个实体对象的情况。

#### `removeAndFlush(entity: Entity): Promise<void>`

* **含义**：从数据库中删除实体对象并立即保存到数据库。
* **区别**：`removeAndFlush` 方法将实体对象标记为待删除状态，并立即执行数据库操作，将更改保存到数据库。
* **使用场景**：适用于需要立即从数据库中删除实体对象的情况。

#### `flush(): Promise<void>`

* **含义**：执行待处理的数据库操作并将更改保存到数据库。
* **区别**：`flush` 方法执行所有待处理的数据库操作，包括添加、删除和更新操作，并将更改保存到数据库。
* **使用场景**：在调用 `persist`、`remove` 或其他更改实体对象状态的方法后，需要调用 `flush` 方法将更改保存到数据库。